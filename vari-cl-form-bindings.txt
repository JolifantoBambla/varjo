*
+
++
-
/
/=
1+
1-
<
<=
=
>
>=
ADJUSTABLE-ARRAY-P
AND
AREF
ARRAY-HAS-FILL-POINTER-P
ARRAY-RANK
ARRAY-ROW-MAJOR-INDEX
ARRAY-TOTAL-SIZE
ARRAYP
BIT-AND
BIT-IOR
BIT-VECTOR-P
BIT-XOR
BREAK
CASE
COERCE
COMPILED-FUNCTION-P
COMPLEMENT
COMPLEX
COMPLEXP
COND
CONJUGATE
CONTINUE
DECF
DENOMINATOR
DO
DOTIMES
EQL
EVENP
EXPT
FLET
FLOAT
FLOAT-DIGITS
FLOAT-RADIX
FLOAT-SIGN
FLOATP
FUNCTION
FUNCTIONP
IDENTITY
IF
IMAGPART
INCF
INTEGER-LENGTH
INTEGERP
ISQRT
KEYWORDP
LABELS
LAMBDA
LET
LET*
LOCALLY
LOGAND
LOGCOUNT
LOGIOR
LOGNOT
LOGXOR
MACROLET
MAKE-ARRAY
MINUSP
MULTIPLE-VALUE-BIND
MULTIPLE-VALUE-CALL
MULTIPLE-VALUE-PROG1
MULTIPLE-VALUE-SETQ
NTH-VALUE
NUMBERP
NUMERATOR
ODDP
OR
PLUSP
PROG1
PROG2
PROGN
RANDOM-STATE-P
RATIONALP
REALP
REALPART
RETURN
ROW-MAJOR-AREF
SETF
SETQ
SIGNUM
SIMPLE-BIT-VECTOR-P
SIMPLE-VECTOR-P
SLOT-VALUE
SVREF
SYMBOL-MACROLET
SYMBOLP
THE
TYPECASE
UNLESS
VALUES
VECTOR
VECTORP
WHEN
WITH-ACCESSORS
WITH-SLOTS
ZEROP



#### With CL Docs

((ADJUSTABLE-ARRAY-P
  "Return T if and only if calling ADJUST-ARRAY on ARRAY will return
   the identical object.")
 (AREF "Return the element of the ARRAY specified by the SUBSCRIPTS.")
 (ARRAY-HAS-FILL-POINTER-P
  "Return T if the given ARRAY has a fill pointer, or NIL otherwise.")
 (ARRAY-RANK "Return the number of dimensions of ARRAY.")
 (ARRAY-TOTAL-SIZE "Return the total number of elements in the Array.")
 (ARRAYP "Return true if OBJECT is an ARRAY, and NIL otherwise.")
 (BIT-AND
  "Perform a bit-wise LOGAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.")
 (BIT-IOR
  "Perform a bit-wise LOGIOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.")
 (BIT-VECTOR-P "Return true if OBJECT is a BIT-VECTOR, and NIL otherwise.")
 (BIT-XOR
  "Perform a bit-wise LOGXOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.")
 (BREAK
  "Print a message and invoke the debugger without allowing any possibility
of condition handling occurring.")
 (CASE "CASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If a singleton key is T then the clause is a default clause.")
 (COERCE "Coerce the Object to an object of type Output-Type-Spec.")
 (COMPILED-FUNCTION-P
  "Return true if OBJECT is a COMPILED-FUNCTION, and NIL otherwise.")
 (COMPLEMENT
  "Return a new function that returns T whenever FUNCTION returns NIL and
   NIL whenever FUNCTION returns non-NIL.")
 (COMPLEX
  "Return a complex number with the specified real and imaginary components.")
 (COMPLEXP "Return true if OBJECT is a COMPLEX, and NIL otherwise.")
 (CONJUGATE
  "Return the complex conjugate of NUMBER. For non-complex numbers, this is
  an identity.")
 (CONTINUE
  "Transfer control to a restart named CONTINUE, or return NIL if none exists.")
 (DECF "The first argument is some location holding a number. This number is
  decremented by the second argument, DELTA, which defaults to 1.")
 (DENOMINATOR "Return the denominator of NUMBER, which must be rational.")
 (DO "DO ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*
  Iteration construct. Each Var is initialized in parallel to the value of the
  specified Init form. On subsequent iterations, the Vars are assigned the
  value of the Step form (if any) in parallel. The Test is evaluated before
  each evaluation of the body Forms. When the Test is true, the Exit-Forms
  are evaluated as a PROGN, with the result being the value of the DO. A block
  named NIL is established around the entire expansion, allowing RETURN to be
  used as an alternate exit mechanism.")
 (EVENP "Is this integer even?") (EXPT "Return BASE raised to the POWER.")
 (FLET "FLET ({(name lambda-list declaration* form*)}*) declaration* body-form*

Evaluate the BODY-FORMS with local function definitions. The bindings do
not enclose the definitions; any use of NAME in the FORMS will refer to the
lexically apparent function definition in the enclosing environment.")
 (FLOAT "Converts any REAL to a float. If OTHER is not provided, it returns a
  SINGLE-FLOAT if NUMBER is not already a FLOAT. If OTHER is provided, the
  result is the same float format as OTHER.")
 (FLOAT-RADIX
  "Return (as an integer) the radix b of its floating-point argument.")
 (FLOAT-SIGN "Return a floating-point number that has the same sign as
   FLOAT1 and, if FLOAT2 is given, has the same absolute value
   as FLOAT2.")
 (FLOATP "Return true if OBJECT is a FLOAT, and NIL otherwise.")
 #'"FUNCTION name

Return the lexically apparent definition of the function NAME. NAME may also
be a lambda expression."
 (FUNCTIONP "Return true if OBJECT is a FUNCTION, and NIL otherwise.")
 (IDENTITY "This function simply returns what was passed to it.")
 (IF "IF predicate then [else]

If PREDICATE evaluates to true, evaluate THEN and return its values,
otherwise evaluate ELSE and return its values. ELSE defaults to NIL.")
 (IMAGPART "Extract the imaginary part of a number.")
 (INCF "The first argument is some location holding a number. This number is
  incremented by the second argument, DELTA, which defaults to 1.")
 (INTEGER-LENGTH
  "Return the number of non-sign bits in the twos-complement representation
  of INTEGER.")
 (INTEGERP "Return true if OBJECT is an INTEGER, and NIL otherwise.")
 (ISQRT
  "Return the greatest integer less than or equal to the square root of N.")
 (KEYWORDP "Return true if Object is a symbol in the \"KEYWORD\" package.")
 (LABELS "LABELS ({(name lambda-list declaration* form*)}*) declaration* body-form*

Evaluate the BODY-FORMS with local function definitions. The bindings enclose
the new definitions, so the defined functions can call themselves or each
other.")
 (LET "LET ({(var [value]) | var}*) declaration* form*

During evaluation of the FORMS, bind the VARS to the result of evaluating the
VALUE forms. The variables are bound in parallel after all of the VALUES forms
have been evaluated."
   )
 (LET* "LET* ({(var [value]) | var}*) declaration* form*

Similar to LET, but the variables are bound sequentially, allowing each VALUE
form to reference any of the previous VARS."
   )
 (LOCALLY
  "LOCALLY declaration* form*

Sequentially evaluate the FORMS in a lexical environment where the
DECLARATIONS have effect. If LOCALLY is a top level form, then the FORMS are
also processed as top level forms.")
 (LOGAND "Return the bit-wise and of its arguments. Args must be integers.")
 (LOGCOUNT "Count the number of 1 bits if INTEGER is non-negative,
and the number of 0 bits if INTEGER is negative.")
 (LOGIOR "Return the bit-wise or of its arguments. Args must be integers.")
 (LOGNOT "Return the bit-wise logical not of integer.")
 (LOGXOR
  "Return the bit-wise exclusive or of its arguments. Args must be integers.")
 (MACROLET "MACROLET ({(name lambda-list form*)}*) body-form*

Evaluate the BODY-FORMS in an environment with the specified local macros
defined. NAME is the local macro name, LAMBDA-LIST is a DEFMACRO style
destructuring lambda list, and the FORMS evaluate to the expansion.")
 (MINUSP "Is this real number strictly negative?")
 (MULTIPLE-VALUE-CALL "MULTIPLE-VALUE-CALL function values-form*

Call FUNCTION, passing all the values of each VALUES-FORM as arguments,
values from the first VALUES-FORM making up the first argument, etc.")
 (MULTIPLE-VALUE-PROG1 "MULTIPLE-VALUE-PROG1 values-form form*

Evaluate VALUES-FORM and then the FORMS, but return all the values of
VALUES-FORM.")
 (NTH-VALUE "Evaluate FORM and return the Nth value (zero based)
 without consing a temporary list of values.")
 (NUMBERP "Return true if OBJECT is a NUMBER, and NIL otherwise.")
 (NUMERATOR "Return the numerator of NUMBER, which must be rational.")
 (ODDP "Is this integer odd?") (PLUSP "Is this real number strictly positive?")
 (PROGN
  "PROGN form*

Evaluates each FORM in order, returning the values of the last form. With no
forms, returns NIL.")
 (RATIONALP "Return true if OBJECT is a RATIONAL, and NIL otherwise.")
 (REALP "Return true if OBJECT is a REAL, and NIL otherwise.")
 (REALPART "Extract the real part of a number.")
 (ROW-MAJOR-AREF
  "Return the element of array corresponding to the row-major index. This is
   SETFable.")
 (SETF "Takes pairs of arguments like SETQ. The first is a place and the second
  is the value that is supposed to go into that place. Returns the last
  value. The place argument may be any of the access forms for which SETF
  knows a corresponding setting form.")
 (SIGNUM
  "If NUMBER is zero, return NUMBER, else return (/ NUMBER (ABS NUMBER)).")
 (SIMPLE-BIT-VECTOR-P
  "Return true if OBJECT is a SIMPLE-BIT-VECTOR, and NIL otherwise.")
 (SIMPLE-VECTOR-P
  "Return true if OBJECT is a SIMPLE-VECTOR, and NIL otherwise.")
 (SVREF "Return the INDEXth element of the given Simple-Vector.")
 (SYMBOL-MACROLET "SYMBOL-MACROLET ({(name expansion)}*) decl* form*

Define the NAMES as symbol macros with the given EXPANSIONS. Within the
body, references to a NAME will effectively be replaced with the EXPANSION."
   )
 (SYMBOLP "Return true if OBJECT is a SYMBOL, and NIL otherwise.")
 (THE "Specifies that the values returned by FORM conform to the VALUE-TYPE.

CLHS specifies that the consequences are undefined if any result is
not of the declared type, but SBCL treats declarations as assertions
as long as SAFETY is at least 2, in which case incorrect type
information will result in a runtime type-error instead of leading to
eg. heap corruption. This is however expressly non-portable: use
CHECK-TYPE instead of THE to catch type-errors at runtime. THE is best
considered an optimization tool to inform the compiler about types it
is unable to derive from other declared types.")
 (TYPECASE "TYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true.")
 (UNLESS "If the first argument is not true, the rest of the forms are
evaluated as a PROGN.")
 (VALUES "Return all arguments, in order, as values.")
 (VECTOR "Construct a SIMPLE-VECTOR from the given objects.")
 (VECTORP "Return true if OBJECT is a VECTOR, and NIL otherwise.")
 (WHEN "If the first argument is true, the rest of the forms are
evaluated as a PROGN.")
 (ZEROP "Is this number zero?"))



#### WIthout CL Docs

(++ AND ARRAY-ROW-MAJOR-INDEX COND DOTIMES EQL FLOAT-DIGITS LAMBDA MAKE-ARRAY
 MULTIPLE-VALUE-BIND MULTIPLE-VALUE-SETQ OR PROG1 PROG2 RANDOM-STATE-P RETURN
 SETQ SLOT-VALUE WITH-ACCESSORS WITH-SLOTS)
